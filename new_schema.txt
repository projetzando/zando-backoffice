--SQL DÃ©finitions (TABLES & VIEWS) NKUNA MarketPlace

-- ENUMS
user_role	buyer, seller, admin

order_status	pending, confirmed, shipped, delivered, cancelled

payment_status	pending, completed, failed

product_type	simple, variable

--TABLES

create table public.profiles (
  id uuid not null,
  first_name text null,
  last_name text null,
  phone text null,
  role public.user_role null default 'buyer'::user_role,
  avatar_url text null,
  created_at timestamp with time zone null default now(),
  constraint profiles_pkey primary key (id),
  constraint profiles_id_fkey foreign KEY (id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create trigger on_profile_seller_created
after
update on profiles for EACH row
execute FUNCTION handle_new_seller ();


create table public.sellers (
  id uuid not null default gen_random_uuid (),
  user_id uuid null,
  company_name text not null,
  company_description text null,
  company_logo text null,
  phone text null,
  email text null,
  website text null,
  is_approved boolean null default false,
  created_at timestamp with time zone null default now(),
  constraint sellers_pkey primary key (id),
  constraint sellers_user_id_key unique (user_id),
  constraint sellers_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;


create table public.addresses (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  name text not null,
  phone text null,
  address_line text not null,
  city text not null,
  is_default boolean null default false,
  created_at timestamp with time zone null default now(),
  constraint addresses_pkey primary key (id),
  constraint addresses_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;


create table public.categories (
  id uuid not null default gen_random_uuid (),
  name text not null,
  image text null,
  is_active boolean null default true,
  constraint categories_pkey primary key (id)
) TABLESPACE pg_default;


create table public.products (
  id uuid not null default gen_random_uuid (),
  seller_id uuid not null,
  category_id uuid null,
  title text not null,
  description text not null,
  price numeric(10, 2) null,
  sale_price numeric(10, 2) null,
  stock integer not null default 0,
  images text[] null,
  is_active boolean null default true,
  is_featured boolean null default false,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  cover_image text null,
  product_type public.product_type null default 'simple'::product_type,
  constraint products_pkey primary key (id),
  constraint products_category_id_fkey foreign KEY (category_id) references categories (id),
  constraint products_seller_id_fkey foreign KEY (seller_id) references sellers (id) on delete CASCADE,
  constraint valid_price check ((price > (0)::numeric)),
  constraint valid_sale_price check (
    (
      (sale_price is null)
      or (sale_price < price)
    )
  ),
  constraint valid_stock check ((stock >= 0))
) TABLESPACE pg_default;

create index IF not exists idx_products_seller on public.products using btree (seller_id) TABLESPACE pg_default;

create index IF not exists idx_products_category on public.products using btree (category_id) TABLESPACE pg_default
where
  (is_active = true);

create index IF not exists idx_products_featured on public.products using btree (is_featured) TABLESPACE pg_default
where
  (is_featured = true);

create index IF not exists idx_products_search on public.products using gin (
  to_tsvector(
    'french'::regconfig,
    ((title || ' '::text) || description)
  )
) TABLESPACE pg_default;

create trigger update_products_timestamp BEFORE
update on products for EACH row
execute FUNCTION update_updated_at ();

create table public.product_attributes (
  id uuid not null default gen_random_uuid (),
  product_id uuid not null,
  name text not null,
  values
    text not null,
    created_at timestamp with time zone null default now(),
    constraint product_attributes_pkey primary key (id),
    constraint product_attributes_product_id_name_key unique (product_id, name),
    constraint product_attributes_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_product_attributes_product on public.product_attributes using btree (product_id) TABLESPACE pg_default;


create table public.product_variations (
  id uuid not null default gen_random_uuid (),
  product_id uuid not null,
  variation_name text not null,
  attributes jsonb not null,
  price numeric(10, 2) null,
  sale_price numeric(10, 2) null,
  stock integer null default 0,
  cover_image text null,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  constraint product_variations_pkey primary key (id),
  constraint product_variations_product_id_attributes_key unique (product_id, attributes),
  constraint product_variations_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint valid_variation_price check (
    (
      (price is null)
      or (price > (0)::numeric)
    )
  ),
  constraint valid_variation_sale_price check (
    (
      (sale_price is null)
      or (sale_price < price)
    )
  ),
  constraint valid_variation_stock check ((stock >= 0))
) TABLESPACE pg_default;

create index IF not exists idx_product_variations_product on public.product_variations using btree (product_id) TABLESPACE pg_default
where
  (is_active = true);

create index IF not exists idx_product_variations_attributes on public.product_variations using gin (attributes) TABLESPACE pg_default;



create table public.orders (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  status public.order_status null default 'pending'::order_status,
  total_amount numeric(10, 2) not null,
  shipping_cost numeric(10, 2) null default 0,
  delivery_name text not null,
  delivery_phone text null,
  delivery_address text not null,
  delivery_city text not null,
  payment_method text not null,
  notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint orders_pkey primary key (id),
  constraint orders_user_id_fkey foreign KEY (user_id) references auth.users (id),
  constraint valid_shipping check ((shipping_cost >= (0)::numeric)),
  constraint valid_total check ((total_amount > (0)::numeric))
) TABLESPACE pg_default;

create index IF not exists idx_orders_user on public.orders using btree (user_id) TABLESPACE pg_default;

create trigger update_orders_timestamp BEFORE
update on orders for EACH row
execute FUNCTION update_updated_at ();


create table public.order_items (
  id uuid not null default gen_random_uuid (),
  order_id uuid not null,
  product_id uuid not null,
  variant_id uuid null,
  seller_id uuid not null,
  product_title text not null,
  variant_name text null,
  quantity integer not null,
  unit_price numeric(10, 2) not null,
  total_price numeric(10, 2) not null,
  variation_id uuid null,
  variation_name text null,
  constraint order_items_pkey primary key (id),
  constraint order_items_product_id_fkey foreign KEY (product_id) references products (id),
  constraint order_items_order_id_fkey foreign KEY (order_id) references orders (id) on delete CASCADE,
  constraint order_items_variation_id_fkey foreign KEY (variation_id) references product_variations (id) on delete set null,
  constraint order_items_seller_id_fkey foreign KEY (seller_id) references sellers (id),
  constraint valid_order_quantity check ((quantity > 0)),
  constraint valid_unit_price check ((unit_price > (0)::numeric))
) TABLESPACE pg_default;

create index IF not exists idx_order_items_order on public.order_items using btree (order_id) TABLESPACE pg_default;

create index IF not exists idx_order_items_seller on public.order_items using btree (seller_id) TABLESPACE pg_default;

create index IF not exists idx_order_items_variation on public.order_items using btree (variation_id) TABLESPACE pg_default;


create table public.cart_items (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  product_id uuid not null,
  variant_id uuid null,
  quantity integer not null default 1,
  created_at timestamp with time zone null default now(),
  variation_id uuid null,
  constraint cart_items_pkey primary key (id),
  constraint cart_items_user_id_product_id_variant_id_key unique (user_id, product_id, variant_id),
  constraint cart_items_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint cart_items_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint cart_items_variation_id_fkey foreign KEY (variation_id) references product_variations (id) on delete CASCADE,
  constraint valid_quantity check ((quantity > 0))
) TABLESPACE pg_default;

create index IF not exists idx_cart_user on public.cart_items using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_cart_items_variation on public.cart_items using btree (variation_id) TABLESPACE pg_default;


--JE NE PENSE PAS AVOIR UTILISE cart_reservations DANS L'APP MOBILE

create table public.cart_reservations (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  product_id uuid not null,
  variant_id uuid null,
  quantity integer not null default 1,
  reserved_at timestamp with time zone null default now(),
  expires_at timestamp with time zone null default (now() + '00:30:00'::interval),
  constraint cart_reservations_pkey primary key (id),
  constraint cart_reservations_user_id_product_id_variant_id_key unique (user_id, product_id, variant_id),
  constraint cart_reservations_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint cart_reservations_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint cart_reservations_variant_id_fkey foreign KEY (variant_id) references product_variations (id) on delete CASCADE,
  constraint valid_reservation_quantity check ((quantity > 0))
) TABLESPACE pg_default;

create index IF not exists idx_cart_reservations_user on public.cart_reservations using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_cart_reservations_product on public.cart_reservations using btree (product_id) TABLESPACE pg_default;

create index IF not exists idx_cart_reservations_expires on public.cart_reservations using btree (expires_at) TABLESPACE pg_default;


create table public.favorites (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  product_id uuid not null,
  created_at timestamp with time zone null default now(),
  constraint favorites_pkey primary key (id),
  constraint favorites_user_id_product_id_key unique (user_id, product_id),
  constraint favorites_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint favorites_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_favorites_user on public.favorites using btree (user_id) TABLESPACE pg_default;


create table public.conversations (
  id uuid not null default gen_random_uuid (),
  seller_id uuid not null,
  buyer_id uuid not null,
  last_message text null,
  last_message_at timestamp with time zone null default now(),
  created_at timestamp with time zone null default now(),
  constraint conversations_pkey primary key (id),
  constraint unique_conversation_participants unique (seller_id, buyer_id),
  constraint conversations_buyer_id_fkey foreign KEY (buyer_id) references auth.users (id),
  constraint conversations_seller_id_fkey foreign KEY (seller_id) references sellers (id)
) TABLESPACE pg_default;

create index IF not exists idx_conversations_participants on public.conversations using btree (seller_id, buyer_id) TABLESPACE pg_default;

create table public.messages (
  id uuid not null default gen_random_uuid (),
  conversation_id uuid not null,
  sender_id uuid not null,
  content text not null,
  is_read boolean null default false,
  created_at timestamp with time zone null default now(),
  product_id uuid null,
  constraint messages_pkey primary key (id),
  constraint messages_conversation_id_fkey foreign KEY (conversation_id) references conversations (id) on delete CASCADE,
  constraint messages_product_id_fkey foreign KEY (product_id) references products (id),
  constraint messages_sender_id_fkey foreign KEY (sender_id) references auth.users (id)
) TABLESPACE pg_default;

create index IF not exists idx_messages_conversation on public.messages using btree (conversation_id, created_at) TABLESPACE pg_default;

create index IF not exists idx_messages_product on public.messages using btree (product_id) TABLESPACE pg_default
where
  (product_id is not null);


create table public.reviews (
  id uuid not null default gen_random_uuid (),
  product_id uuid not null,
  user_id uuid not null,
  order_id uuid null,
  rating integer not null,
  comment text null,
  images text[] null,
  created_at timestamp with time zone null default now(),
  constraint reviews_pkey primary key (id),
  constraint reviews_user_id_product_id_key unique (user_id, product_id),
  constraint reviews_order_id_fkey foreign KEY (order_id) references orders (id),
  constraint reviews_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint reviews_user_id_fkey foreign KEY (user_id) references auth.users (id),
  constraint valid_rating check (
    (
      (rating >= 1)
      and (rating <= 5)
    )
  )
) TABLESPACE pg_default;


create table public.payments (
  id uuid not null default gen_random_uuid (),
  order_id uuid not null,
  amount numeric(10, 2) not null,
  method text not null,
  status public.payment_status null default 'pending'::payment_status,
  transaction_ref text null,
  created_at timestamp with time zone null default now(),
  constraint payments_pkey primary key (id),
  constraint payments_order_id_fkey foreign KEY (order_id) references orders (id) on delete CASCADE,
  constraint valid_payment_amount check ((amount > (0)::numeric))
) TABLESPACE pg_default;



--VIEWS
create view public.products_with_price as
select
  id,
  seller_id,
  category_id,
  title,
  description,
  price,
  sale_price,
  stock,
  images,
  is_active,
  is_featured,
  created_at,
  updated_at,
  cover_image,
  product_type,
  get_product_display_price (id) as display_price,
  get_product_total_stock (id) as available_stock,
  (
    select
      count(*) as count
    from
      reviews
    where
      reviews.product_id = p.id
  ) as review_count,
  (
    select
      round(avg(reviews.rating), 1) as round
    from
      reviews
    where
      reviews.product_id = p.id
  ) as avg_rating,
  case
    when product_type = 'variable'::product_type then (
      select
        json_agg(
          json_build_object(
            'id',
            pv.id,
            'variation_name',
            pv.variation_name,
            'attributes',
            pv.attributes,
            'price',
            pv.price,
            'sale_price',
            pv.sale_price,
            'stock',
            pv.stock,
            'cover_image',
            pv.cover_image,
            'is_active',
            pv.is_active
          )
          order by
            pv.variation_name
        ) as json_agg
      from
        product_variations pv
      where
        pv.product_id = p.id
        and pv.is_active = true
        and pv.price is not null
    )
    else null::json
  end as variations
from
  products p
where
  is_active = true;


create view public.cart_with_details as
select
  c.id,
  c.user_id,
  c.product_id,
  c.variant_id,
  c.quantity,
  c.created_at,
  c.variation_id,
  p.title as product_title,
  p.cover_image as product_image,
  case
    when c.variation_id is not null then (
      select
        pv.variation_name
      from
        product_variations pv
      where
        pv.id = c.variation_id
    )
    when c.variant_id is not null then (
      select
        pv.variation_name
      from
        product_variations pv
      where
        pv.id = c.variant_id
    )
    else ''::text
  end as variation_name,
  case
    when c.variation_id is not null then (
      select
        pv.variation_name
      from
        product_variations pv
      where
        pv.id = c.variation_id
    )
    when c.variant_id is not null then (
      select
        pv.variation_name
      from
        product_variations pv
      where
        pv.id = c.variant_id
    )
    else ''::text
  end as variant_name,
  case
    when c.variation_id is not null then (
      select
        COALESCE(pv.sale_price, pv.price) as "coalesce"
      from
        product_variations pv
      where
        pv.id = c.variation_id
    )
    when c.variant_id is not null then (
      select
        COALESCE(pv.sale_price, pv.price) as "coalesce"
      from
        product_variations pv
      where
        pv.id = c.variant_id
    )
    else COALESCE(p.sale_price, p.price)
  end as unit_price,
  case
    when c.variation_id is not null then (
      select
        COALESCE(pv.sale_price, pv.price) as "coalesce"
      from
        product_variations pv
      where
        pv.id = c.variation_id
    )
    when c.variant_id is not null then (
      select
        COALESCE(pv.sale_price, pv.price) as "coalesce"
      from
        product_variations pv
      where
        pv.id = c.variant_id
    )
    else COALESCE(p.sale_price, p.price)
  end * c.quantity::numeric as total_price
from
  cart_items c
  join products p on c.product_id = p.id;